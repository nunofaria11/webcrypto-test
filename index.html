<!doctype html>
<html>

<head>
  <title>Crypto test</title>
</head>

<body>
  <div id="content">
    <div>
      <textarea id="raw" placeholder="Text to encrypt..."></textarea>
      <br>
      <button id="encryptBtn">Encrypt</button>
    </div>
    <div>
      <textarea id="encrypted" disabled="true"></textarea>
      <br>
      <button id="decryptBtn">Decrypt</button>
    </div>
    <div>
      <textarea id="decrypted" disabled="true"></textarea>
    </div>
    <ul id="messages"></ul>
  </div>
  <script type="text/javascript">
  var crypto = window.crypto || window.msCrypto;
  crypto.subtle = crypto.subtle || crypto.webkitSubtle;

  var raw = document.getElementById('raw');
  var encrypted = document.getElementById('encrypted');
  var decrypted = document.getElementById('decrypted');
  var encryptBtn = document.getElementById('encryptBtn');
  var decryptBtn = document.getElementById('decryptBtn');

  raw.disabled = true;
  encryptBtn.disabled = true;
  decryptBtn.disabled = true;

  // https://www.w3.org/TR/WebCryptoAPI/#subtlecrypto-interface
  if (crypto.subtle) {
    var public_key_object, private_key_object, promise_key;

    public_key_object = null;
    private_key_object = null;

    var algorithmIdentifier = {
      // Algorithm name
      name: "RSA-OAEP",
      // iv: Is initialization vector. It must be 16 bytes
      iv: crypto.getRandomValues(new Uint8Array(16))
    };

    var asymmetricEncAlgorithm = {
      name: "RSA-OAEP",
      modulusLength: 2048,
      publicExponent: new Uint8Array([0x01, 0x00, 0x01]),
      hash: {
        name: "SHA-256"
      }
    };

    promise_key = crypto.subtle.generateKey(
      asymmetricEncAlgorithm, // algorithm
      false, // extractable (https://www.w3.org/TR/WebCryptoAPI/#dfn-CryptoKey-slot-extractable)
      ["encrypt", "decrypt"] // usages
    );

    promise_key.then(
      function(key) {
        private_key_object = key.privateKey;
        public_key_object = key.publicKey;
        addMessage('Keys generated.');
        console.log('Keys generated.', key);
        
        raw.disabled = false;
        encryptBtn.disabled = false;
        decryptBtn.disabled = false;
      },
      function(err) {
        console.error('An error occurred:', err || '?');
        addMessage('Error ' + (err || '?'));
      }
    );

  } else {
    addMessage('crypto.subtle is not supported');
  }

  encryptBtn.onclick = function(evt) {
    encryptData(raw.value).then(
      function(encData) {
        encrypted.value = encData;
        decrypted.value = '';
      },
      function(error) {
        addMessage('Error encrypting.')
        console.error('Error encrypting.', error || '?');
      }
    );
  };

  decryptBtn.onclick = function(evt) {
    var value = convertTextareaValueToArrayBufferView(encrypted.value);
    decryptData(value).then(
      function(decData) {
        decrypted.value = decData;
      },
      function(error) {
        addMessage('Error decrypting.')
        console.error('Error decrypting.', error || '?');
      }
    );
  };

  function decryptData(rawData) {
    return new Promise(function(resolve, reject) {
      crypto.subtle.decrypt(
        algorithmIdentifier,
        private_key_object,
        rawData
      ).then(
        function(result) {
          resolve(convertArrayBufferViewtoString(new Uint8Array(result)));
        },
        reject);
    });
  }

  function encryptData(data) {
    var promise = new Promise(
      function(resolve, reject) {
        crypto.subtle.encrypt(
          algorithmIdentifier,
          public_key_object,
          convertStringToArrayBufferView(data)
        ).then(
          function(result) {
            resolve(new Uint8Array(result));
          },
          function(error) {
            reject(error);
          }
        );
      });
    return promise;
  }

  function convertTextareaValueToArrayBufferView(value) {
    var splits = value.split(',');
    var bytes = new Uint8Array(splits.length);
    for (var iii = 0; iii < splits.length; iii++) {
      bytes[iii] = parseInt(splits[iii]);
    }
    return bytes;
  }

  function convertStringToArrayBufferView(str) {
    var bytes = new Uint8Array(str.length);
    for (var iii = 0; iii < str.length; iii++) {
      bytes[iii] = str.charCodeAt(iii);
    }

    return bytes;
  }

  function convertArrayBufferViewtoString(buffer) {
    var str = "";
    for (var iii = 0; iii < buffer.byteLength; iii++) {
      str += String.fromCharCode(buffer[iii]);
    }

    return str;
  }

  function addMessage(message) {
    var messages = document.getElementById('messages');
    var node = document.createElement('li');
    node.appendChild(document.createTextNode(message));
    messages.appendChild(node);
  }
  </script>
</body>

</html>
